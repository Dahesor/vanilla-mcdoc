use ::java::server::util::text::Text
use super::util::MinMaxBounds
use super::util::RandomIntGenerator

dispatch minecraft:resource[loot_table] to struct LootTable {
	type?: #[id] LootContextType,
	pools?: [LootPool],
	functions?: [LootFunction],
}

enum(string) LootContextType {
	Empty = "empty",
	Chest = "chest",
	Command = "command",
	Selector = "selector",
	Fishing = "fishing",
	Entity = "entity",
	Gift = "gift",
	Barter = "barter",
	AdvancementReward = "advancement_reward",
	AdvancementEntity = "advancement_entity",
	Generic = "generic",
	Block = "block",
	#[since="1.20.5"]
	Equipment = "equipment",
}

struct LootPool {
	rolls: RandomIntGenerator,
	bonus_rolls?: MinMaxBounds<float>,
	entries: [LootPoolEntry],
	functions?: [LootFunction],
	conditions?: [LootCondition],
}

struct LootPoolEntry {
	type: #[id="loot_pool_entry_type"] string,
	...minecraft:loot_pool_entry[[type]],
}

struct LootPoolEntryBase {
	functions?: [LootFunction],
	conditions?: [LootCondition],
}

type LootPoolEntrySingleton<Name> = struct {
	name: Name,
	weight?: int @ 1..,
	quality?: int,
	...LootPoolEntryBase,
}

/// Gets block specific drops.
dispatch minecraft:loot_pool_entry[dynamic] to LootPoolEntrySingleton<#[id] string>

/// Adds a single item.
dispatch minecraft:loot_pool_entry[item] to LootPoolEntrySingleton<#[id="item"] string>

/// Adds the contents of another loot table.
dispatch minecraft:loot_pool_entry[loot_table] to LootPoolEntrySingleton<#[id="loot_table"] string>

/// Adds the contents of an item tag.
dispatch minecraft:loot_pool_entry[tag] to LootPoolEntrySingleton<#[id(registry="item",tags="implicit")] string>

struct CompositePoolEntry {
	children: [LootPoolEntry],
	...LootPoolEntryBase,
}

/// Tests conditions of the child entries and executes the first that can run.
dispatch minecraft:loot_pool_entry[alternatives] to CompositePoolEntry

/// Executes all child entries when own conditions pass.
dispatch minecraft:loot_pool_entry[group] to CompositePoolEntry

/// Executes child entries until the first one that can't run due to conditions.
dispatch minecraft:loot_pool_entry[sequence] to CompositePoolEntry

struct LootFunction {
	function: (
		#[until="1.16"] #[id] LootFunctionType |
		#[since="1.16"] #[id="loot_function_type"] string |
	),
	...minecraft:loot_function_type[[function]],
	conditions?: [LootCondition],
}

struct LootCondition {
	condition: (
		#[until="1.16"] #[id] LootConditionType |
		#[since="1.16"] #[id="loot_condition_type"] string |
	),
	...minecraft:loot_condition_type[[condition]],
}

// TODO: Actually write these

enum(string) LootFunctionType {
	EnchantWithLevels = "enchant_with_levels",
}

enum(string) LootConditionType {
	RandomChance = "random_chance",
}
