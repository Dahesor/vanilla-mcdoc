use super::LootCondition
use super::function::EntityTarget
use super::super::util::MinMaxBounds
use super::super::util::NumberProvider
use super::super::util::RandomValueBounds
use super::super::advancement::predicate::ItemPredicate
use super::super::advancement::predicate::EntityPredicate
use super::super::advancement::predicate::LocationPredicate
use super::super::advancement::predicate::DamageSourcePredicate

/// Whether any condition within a list passes.
dispatch minecraft:loot_condition_type[alternative] to struct Alternative {
	terms: [LootCondition],
}

dispatch minecraft:loot_condition_type[block_state_property] to struct BlockStateProperty {
	block: #[id="block"] string,
	properties: struct {
		[string]: string, // TODO
	},
}

dispatch minecraft:loot_condition_type[damage_source_properties] to struct DamageSourceProperties {
	predicate: DamageSourcePredicate,
}

dispatch minecraft:loot_condition_type[entity_properties] to struct EntityProperties {
	entity: EntityTarget,
	predicate: EntityPredicate,
}

dispatch minecraft:loot_condition_type[entity_scores] to struct EntityScores {
	entity: EntityTarget,
	scores: struct {
		[#[command_argument="objective"] string]: (
			#[until="1.17"] RandomValueBounds |
			#[since="1.17"] MinMaxBounds<int> |
		),
	},
}

/// Whether a condition does not pass.
dispatch minecraft:loot_condition_type[inverted] to struct Inverted {
	term: LootCondition,
}

dispatch minecraft:loot_condition_type[killed_by_player] to struct KilledByPlayer {
	inverse?: boolean,
}

dispatch minecraft:loot_condition_type[location_check] to struct LocationCheck {
	offsetX?: int,
	offsetY?: int,
	offsetZ?: int,
	predicate: LocationPredicate,
}

dispatch minecraft:loot_condition_type[match_tool] to struct MatchTool {
	predicate: ItemPredicate,
}

dispatch minecraft:loot_condition_type[random_chance] to struct RandomChance {
	chance: float @ 0..1,
}

dispatch minecraft:loot_condition_type[random_chance_with_looting] to struct RandomChanceWithLooting {
	chance: float @ 0..1,
	/// Looting adjustment to the base success rate. Formula is `chance + (looting_level * looting_multiplier)` .
	looting_multiplier: float,
}

/// Whether another predicate passes.
dispatch minecraft:loot_condition_type[reference] to struct Reference {
	/// A cyclic reference causes a parsing failure.
	name: #[id="predicate"] string,
}

dispatch minecraft:loot_condition_type[table_bonus] to struct TableBonus {
	enchantment: #[id="enchantment"] string,
	/// Probabilities for each enchantment level
	chances: [float @ 0..1],
}

dispatch minecraft:loot_condition_type[time_check] to struct TimeCheck {
	/// Check the current game tick.
	value: (
		#[until="1.17"] RandomValueBounds |
		#[since="1.17"] MinMaxBounds<int> |
	),
	/// Game tick supplied to `value` check gets modulo-divided by this.
	/// For example, if set to 24000, `value` operates on a time period of days.
	period?: long,
}

#[since="1.17"]
dispatch minecraft:loot_condition_type[value_check] to struct ValueCheck {
	value: NumberProvider<int>,
	/// Passes when `value` is within this range.
	range: MinMaxBounds<int>,
}

dispatch minecraft:loot_condition_type[weather_check] to struct WeatherCheck {
	raining?: boolean,
	thundering?: boolean,
}
