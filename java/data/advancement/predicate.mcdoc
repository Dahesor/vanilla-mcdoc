use ::java::server::world::item::DefaultItemComponents
use ::java::server::util::inventory::EquipmentSlot
use super::super::util::MinMaxBounds

struct ItemPredicate {
	#[until="1.20.5"]
	item?: #[id="item"] string,
	#[until="1.20.5"]
	tag?: #[id(registry="item",tags="implicit")] string,
	#[until="1.20.5"]
	durability?: MinMaxBounds<int>,
	#[until="1.20.5"]
	potion?: #[id="potion"] string,
	#[until="1.20.5"]
	enchantments?: [EnchantmentPredicate],
	/// Checks the `StoredEnchantments` nbt tag (used by enchanted books).
	#[until="1.20.5"]
	stored_enchantments?: [EnchantmentPredicate],
	#[until="1.20.5"]
	nbt?: #[nbt=minecraft:item[[item]]] string, // TODO: This needs hardcoding to include DefaultItemTags
	#[since="1.20.5"]
	items?: (#[id(registry="item",tags="allowed")] string | [#[id="item"] string]),
	#[since="1.20.5"]
	count?: MinMaxBounds<int>,
	#[since="1.20.5"]
	components?: struct {
		...DefaultItemComponents,
		...minecraft:item[[items]],
	},
	#[since="1.20.5"]
	predicates?: struct { // This is made like this because of the `items` hack to get good typing for custom data.
		[#[id] "enchantments"]?: [EnchantmentPredicate],
		[#[id] "stored_enchantments"]?: [EnchantmentPredicate],
		[#[id] "potions"]?: (#[id(registry="potion",tags="allowed")] string | [#[id="potion"] string]),
		[#[id] "custom_data"]?: #[nbt=mcdoc:custom_item_data[[items]]] string,
		[#[id] "damage"]?: struct {
			damage?: MinMaxBounds<int>,
			durability?: MinMaxBounds<int>,
		},
		[#[id] "jukebox_playable"]?: struct {
			song?: (#[id(registry="jukebox_song",tags="allowed")] string | [#[id="jukebox_song"] string]),
		}
	},
}

struct EnchantmentPredicate {
	#[until="1.21"]
	enchantment?: #[id="enchantment"] string,
	#[since="1.21"]
	enchantments?: (#[id(registry="enchantment",tags="allowed")] string | [#[id="enchantment"] string]),
	levels?: MinMaxBounds<int>,
}

struct BlockPredicate {
	#[until="1.20.5"]
	block?: #[id="block"] string,
	#[until="1.20.5"]
	tag?: #[id(registry="block",tags="implicit")] string,
	#[since="1.20.5"]
	blocks?: (#[id(registry="block",tags="allowed")] string | [#[id="block"] string]),
	state?: mcdoc:block_states[[blocks]],
	nbt?: #[nbt=minecraft:block[[blocks]]] string,
}

struct FluidPredicate {
	#[until="1.20.5"]
	fluid?: #[id="fluid"] string,
	#[until="1.20.5"]
	tag?: #[id(registry="fluid",tags="implicit")] string,
	#[since="1.20.5"]
	fluids?: (#[id(registry="fluid",tags="allowed")] string | [#[id="fluid"] string]),
	state?: struct {
		[string]: (MinMaxBounds<int> | boolean | string), // TODO
	},
}

struct LocationPredicate {
	position?: struct {
		x?: MinMaxBounds<float>,
		y?: MinMaxBounds<float>,
		z?: MinMaxBounds<float>,
	},
	#[until="1.20.5"]
	biome?: (
		#[until="1.16"] #[id="biome"] string |
		#[since="1.16"] #[id="worldgen/biome"] string |
	),
	#[since="1.20.5"]
	biomes?: (#[id=(registry="worldgen/biome",tags=allowed)] string | [#[id="worldgen/biome"] string]),
	#[until="1.19"]
	feature?: (
		#[until="1.18.2"] string |
		#[since="1.18.2"] #[id="worldgen/configured_structure_feature"] string |
	),
	#[since="1.19"] #[until="1.20.5"]
	structure?: #[id="worldgen/structure"] string,
	#[since="1.20.5"]
	structures?: (#[id=(registry="worldgen/structure",tags=allowed)] string | [#[id="worldgen/structure"] string]),
	dimension?: #[id="dimension"] string,
	/// Calculated using: `max(sky-darkening, block)`.
	light?: struct {
		light?: MinMaxBounds<int @ 0..15>,
	},
	block?: BlockPredicate,
	fluid?: FluidPredicate,
	/// Whether the block is above (5 blocks or less) a campfire or soul campfire.
	#[since="1.16"]
	smokey?: boolean,
	/// Whether the location has the maximum possible level of sky light
	#[since="1.21"]
	can_see_sky?: boolean,
}

struct MovementPredicate {
	x?: MinMaxBounds<float>,
	y?: MinMaxBounds<float>,
	z?: MinMaxBounds<float>,
	speed?: MinMaxBounds<float>,
	horizontal_speed?: MinMaxBounds<float>,
	vertical_speed?: MinMaxBounds<float>,
	fall_distance?: MinMaxBounds<float>,
}

struct EntityPredicate {
	type?: (
		#[id(registry="entity_type",tags="allowed")] string |
		#[since="1.20.5"] [#[id="entity_type"] string] |
	),
	#[since="1.19"]
	type_specific?: TypeSpecificPredicate,
	team?: #[team] string,
	nbt?: #[nbt=minecraft:entity[[type]]] string, // TODO: This needs hardcoding to include AnyEntity
	location?: LocationPredicate,
	distance?: DistancePredicate,
	flags?: struct {
		is_on_fire?: boolean,
		is_sneaking?: boolean,
		is_sprinting?: boolean,
		is_swimming?: boolean,
		is_baby?: boolean,
		#[since="1.21"]
		is_on_ground?: boolean,
		#[since="1.21"]
		is_flying?: boolean,
	},
	equipment?: struct {
		[EquipmentSlot]: ItemPredicate,
	},
	#[until="1.19"]
	player?: PlayerPredicate,
	#[since="1.16"]
	vehicle?: EntityPredicate,
	#[since="1.16"] #[until="1.19"]
	targeted_entity?: EntityPredicate,
	#[since="1.16"] #[until="1.19"]
	fishing_hook?: FishingHookPredicate,
	#[since="1.17"]
	lightning_bolt?: LightningBoltPredicate,
	#[until="1.19"]
	catType?: string,
	effects?: struct {
		[#[id="mob_effect"] string]: MobEffectPredicate,
	},
	#[since="1.20.5"]
	slots?: struct {
		[#[item_slots] string]: ItemPredicate,
	},
	#[since="1.21"]
	movement?: MovementPredicate,
	/// True every `n` ticks of an entity's lifetime.
	#[since="1.21"]
	periodic_ticks?: int @ 1..,
	/// Whether the block at most 0.5 blocks below the entity is present which can affect its movement.
	#[since="1.21"]
	movement_affected_by?: LocationPredicate,
}

struct TypeSpecificPredicate {
	type: SpecificType,
	...minecraft:type_specific_predicate[[type]],
}

enum(string) SpecificType {
	#[until="1.20.5"]
	Any = "any",
	Cat = "cat",
	FishingHook = "fishing_hook",
	Frog = "frog",
	Lightning = "lightning",
	Player = "player",
	Slime = "slime",
	#[since="1.20.5"]
	Wolf = "wolf",
	#[since="1.20.5"]
	Painting = "painting",
	#[since="1.20.5"]
	Raider = "raider",
}

dispatch minecraft:type_specific_predicate[cat] to struct CatPredicate {
	variant?: (#[id(registry="cat_variant",tags="allowed")] string | [#[id="cat_variant"] string]),
}

#[since="1.20.5"]
dispatch minecraft:type_specific_predicate[wolf] to struct WolfPredicate {
	variant?: (#[id(registry="wolf_variant",tags="allowed")] string | [#[id="wolf_variant"] string]),
}

dispatch minecraft:type_specific_predicate[painting] to struct PaintingPredicate {
	variant?: (#[id(registry="painting_variant",tags="allowed")] string | [#[id="painting_variant"] string]),
}

dispatch minecraft:type_specific_predicate[fishing_hook] to struct FishingHookPredicate {
	in_open_water?: boolean,
}

dispatch minecraft:type_specific_predicate[frog] to struct FrogPredicate {
	variant?: (#[id(registry="frog_variant",tags="allowed")] string | [#[id="frog_variant"] string]),
}

dispatch minecraft:type_specific_predicate[lightning] to struct LightningBoltPredicate {
	blocks_set_on_fire?: MinMaxBounds<int>,
	entity_struck?: EntityPredicate,
}

dispatch minecraft:type_specific_predicate[player] to struct PlayerPredicate {
	advancements?: struct {
		[#[id="advancement"] string]: (boolean | struct {
			[string]: boolean,
		}),
	},
	gamemode?: GameMode | [GameMode],
	/// Experience/XP level.
	level?: MinMaxBounds<int>,
	recipes?: struct {
		[#[id="recipe"] string]: boolean,
	},
	stats?: [StatisticPredicate],
	looking_at?: EntityPredicate,
}

dispatch minecraft:type_specific_predicate[slime] to struct SlimePredicate {
	size?: MinMaxBounds<int>,
}

dispatch minecraft:type_specific_predicate[raider] to struct RaiderPredicate {
	has_raid?: boolean,
	is_captain?: boolean,
}

struct DistancePredicate {
	x?: MinMaxBounds<float>,
	y?: MinMaxBounds<float>,
	z?: MinMaxBounds<float>,
	absolute?: MinMaxBounds<float>,
	horizontal?: MinMaxBounds<float>,
}

enum(string) GameMode {
	Survival = "survival",
	Creative = "creative",
	Adventure = "adventure",
	Spectator = "spectator",
}

struct StatisticPredicate {
	type: #[id="stat_type"] string,
	stat: minecraft:statistic_type[[type]],
	value: MinMaxBounds<int>,
}

dispatch minecraft:statistic_type[%unknown] to string

dispatch minecraft:statistic_type[mined] to #[id="block"] string

dispatch minecraft:statistic_type[crafted,used,broken,picked_up,dropped] to #[id="item"] string

dispatch minecraft:statistic_type[killed,killed_by] to #[id="entity_type"] string

dispatch minecraft:statistic_type[custom] to #[id="custom_stat"] string

struct MobEffectPredicate {
	amplifier?: MinMaxBounds<int>,
	duration?: MinMaxBounds<int>,
	ambient?: boolean,
	visible?: boolean,
}

struct DamagePredicate {
	/// Amount of incoming damage before damage reduction.
	dealt?: MinMaxBounds<float>,
	/// Amount of incoming damage after damage reduction.
	taken?: MinMaxBounds<float>,
	/// Whether the damage was successfully blocked.
	blocked?: boolean,
	/// Source of the damage (eg: the skeleton that shot the arrow).
	source_entity?: EntityPredicate,
	#[until="1.19.4"]
	type?: DamageSourcePredicate,
	/// Damage type group tags that the damage type is in.
	#[since="1.19.4"]
	tags?: [DamageTypeSource],
	/// Damage is direct when its direct and source entities are the same.
	#[since="1.21"]
	is_direct?: boolean,
}

struct DamageSourcePredicate {
	is_explosion?: boolean,
	is_fire?: boolean,
	is_magic?: boolean,
	is_projectile?: boolean,
	is_lightning?: boolean,
	bypasses_armor?: boolean,
	bypasses_invulnerability?: boolean,
	bypasses_magic?: boolean,
	source_entity?: EntityPredicate,
	direct_entity?: EntityPredicate,
}

struct DamageTypeSource {
	id: #[id(registry="damage_type",tags="implicit")] string,
	/// Whether the damage is expected to have or not have the tag for the predicate to match.
	expected: boolean,
}
